> 想必大多数人已经看了网上许多的关于动态代理的解释，但似乎仍无法真正明白实际含义，总觉得之前的介绍一套下来说了又好像什么也没说。
> 下面，本文将简单地说明一下JDK的动态代理为何如此实现。

- 首先，我们有一个需要功能增强的类（普通类）。类似于静态代理需要额外生成一个完成了功能增强的代理对象（增强对象）。
- JDK给出了一个Proxy类利用newProxyInstance()方法生成这样一个增强对象。但可惜的是，Proxy已经是一个成熟的类了，我们希望增强对象就像普通类那样具有对应的方法，就需要增强对象继承普通类。
- 无奈Java无法多重继承，退而求其次，指定一个接口包含需要的方法，这样实现了该接口，增强对象就可以使用我们想要的方法。因此，就解释了为什么总要多一个接口。
- 接口放一边。如何实现功能增强，避免静态代理中直接一个个对方法进行编写，这里要求编写另一个类并实现invokehandler接口（增强说明类）。
- 在增强说明类中，首先注入一个普通类的对象，invoke方法中不需要指定特定的方法，而是对各个方法进行拦截，再进行功能增强。
- 通常对invoke的编写就是，先编写一段代码，再由注入的普通类的对象调用方法，可能再写个后续的一段代码，总之实现了功能增强的说明状况。（当然你也可以获取对应的方法名，建立条件语句，根据不同状况，实现不同的增强）

-----------------

- 现在，我们有了一个包含方法实现的普通类，一个或若干个具有方法名的用于增强对象实现的接口，以及说明了功能如何增强的增强说明类。
- 这样就解释了，newProxyInstance()方法为什么有那三个参数了。只不过变成了对应类的加载对象