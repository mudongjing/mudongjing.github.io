### 1 基础操作
#### 1.1 登录
在完成mysql软件的安装后，通常会提醒设置用户名以及密码等信息。
其次，初次使用，可以使用具有视图的软件登录数据库，如navicat for mysql。
最后，在熟悉基本的情况后，可直接在命令行中登录，当然了，在最初安装的时候，大概也是在命令行中操作的。
前提是保证mysql被设置到了环境变量中，否则命令行终端无法识别mysql的命令。
命令行登录：

- 本地登录时，一般不需要过多的信息
```sql
mysql -u用户名 -p密码
```
即可

- 远程服务器登录，则需要额外指定IP地址，保险起见，也包括端口号
```sql
mysql -hIP地址 -P端口号 -u用户名 -p密码
```
密码通常可以不直接写在命令中，只需要`-p`，回车后，自会要求输入密码。端口号一般默认为3306。

#### 1.2 基本操作
mysql会保存多个数据库 `database`，每个数据库中又会保存多个表 `table`。
登录后，通过 `show`语句可查看对应的列表，不过要注意是复数形式。
```sql
show databases;
```
若要查看对应数据库中的表，则用 `use` 选择，
```sql
 use 数据库名;
 show tables;
```
很明显，除了复数外，每个语句后面要加上分号 `;`
若是没有数据库和表，可以通过 `create`语句创建，
```sql
 create database 数据库名;
 create table 表名;
```
最后，mysql 语句是不区分大小写的。
### 2 查表
#### 2.1 列出数据
看到表的列表后，需要查看一下表里有什么内容，表就是一个表格，包含各个列，每个列记录着对应的数据，首先需要查看列名都是什么，可用 `describe`，
```sql
describe 表名;
```
该语句将列出该表内全部的列名，以及列的信息，如整数性质，字符串性质。

然后，需要列出某一个列的数据，如人员的姓名，商品的名称，使用 `select`，
```sql
select 列名1，列名2 from 表名 limit 设定的数量;
```
- 当数据量太大时，比如上万个，光是显示出来就需要个几分钟，因此可以指定显示的数量，用 `limit` 指定最大数量，limit(n,m),指定显示第n行到第m行。
- 若要显示所有列，用星号 `*`代替列名。
- 有时列中有大量相同的数据，看着麻烦，则在 `select`之后加上 `distinct`，作用于之后的所有列，只显示各不相同的值。

#### 2.2 选择数据与排序
##### 2.2.1 指定条件
在商品信息的表中，通常记录着各商品名称及价格，为了提取出价格较便宜的商品，需要设定一个容忍值，要求价格低于此，则用 `where` 语句，
```sql
select 商品名 from 信息表 where 价格<=容忍值 order by 价格 desc;
```
通过 `where`过滤掉不符合要求的数据。后面的 `order by`，顾名思义时指定排序依据，将商品名按照价格的大小顺序输出，没有 `desc`时默认从小到大，`desc`则指定为逆序排列。

- `where` 可以使用正常编程中的大小对比符号，不等于可以是 `!=` 或 `<>`。表示范围可用 `between and `
- 判断空值 NULL，用 `is NULL`，当然 `is`也可用判断其它条件，反之的有 `not`
- 多个条件用 `and` 或 `or` 连接
- 如果只是希望数值在某个集合中， 可用 `in (n1,n2,..,nm)`表示
##### 2.2.2 分组
有时给出商品的生产商名称，我们需要统计各个生产商有多少商品，则用到 `group by`，
```sql
select 生产商 ,count(商品名称) as 商品数量 from 信息表 group by 生产商
```
用**group by**将表按照生产商分组，即生产商变成一个被合并的行。**count()**统计数量的函数，给出每个生产商产生的新的行中对应的商品的数量，用 `as` 命名一个新的列名作为输出，当然并不会在原表中产生这个列，只是临时的。

- 同样的可以用 `as` 在语句中临时地命名列名，表明，数据库名，有时为了显示对应的意义，有时是方面写语句
- 此外，对应分组后的条件可用 `having`表达，如 **having count(商品名称)>100**

### 3 操作表
#### 3.1 表
- 创建表
前面简单介绍了创建表用 `create`语句，但是，一般我们需要在创建时指定表的内容，即需要存储的不同列，以及这些列的属性，最后，需要设置一个主键，作为各个行的唯一值。
```sql
create table 信息表
(
id int not NULL auto_increment,
商品名 char(10) not NULL,
生产商 char(50) NULL,
primary key (id)
)engine=InnoDB;
```
上述语句，给表创建了几个列， `auto_increment`指每次插入行时，该行的**id**自动增1，同时规定了它不能为**NULL**，为它之后称为主键**primary key**奠定必要基础。`char()` 语句指定该列的值为字符串，有的可以为空，有的则不行。其中，类型括号中的数值表示能够显示的字符个数。
最后，指出该表的引擎为InnoDB。
 1. 此外，主键的要求是唯一性，可以使用多个列共同组成主键，只要这个组合保证唯一性，且不为空。
 2. 对于自增的id值，可以使用 `last_insert_id()`函数给出最后一个 `auto_increment`的值。
 3. 在设定列名时，可以用 `default`指定默认值。

- 删除表
这里非常简单，直接用 `drop`语句，
```sql
drop table 表名;
drop database 数据库名;
```
上述语句，表明删除数据库可以使用同样的语法。

- 更新表
1. 重命名表，
```sql
rename table 旧表名 to 新表名;
```
2. 修改表结构
使用 `alter`语句，

```sql
--添加列
alter table 表名 add 新列名(对应的属性);
--删除列
alter table 表名 drop column 列名;
```
上述同样表明 `--`是mysql中的注释符号。

#### 3.2 行
- 删除行
```sql
delete from 表名 where 条件;
```
- 插入行

```sql
insert into 表名
values(
值1,
值2,...,
值n);--这里需要保证输入的值与实际的列是对应的
```
```sql
insert into 表名(列1,列2,..)
values(值1,值2,...);--这里列出列名与对应的值，若需要赋的列名一样，可以跟多个values
```
- 更新行
```sql
update 表名 set 列名=新值 where 条件;
update 表名 set 列名=NULL where 条件;--将对应的列的值删除
update ignore 表名 set 列名=新值 where 条件;--忽视可能发生的错误
```
`set`后可跟多个列的操作

### 4 多表查询
上述的操作基本上就是日常的基础操作了，但实际工作中，由于记录的东西复杂又大，如前面提到的商品信息，每个商品都需要记录一个生产商，生产商又具有自己的地址等信息，如果每个商品后面都附带这么多的信息，则浪费资源。于是，我们需要将信息分开，商品通过id在其它表中可以找到自己的生产商，而这样的操作则变成了多个表的查询，以及外键，联结等知识。

- 首先多表之间的查询，只需要在对应的列前面指明对应的表即可，
- 外键，如同前面所属的商品与生产商，在商品的表中添加一列生产商信息，但列中保存的是id值，对应另一个生产商的表，则id对应的列属于外键。

```sql
select a.列1,b.列1 from 表1 as a , 表2 as b where a.列1 条件 b.列1;
```
上述实际就是一个联结操作，所谓的联结就是多表查询。
#### 4.1 联结
多表联结，就是以此查询多个表，比对列的值。只不过，稍微特殊的是，两个表的查询。其次，不要添加无用的表进行查询，会极大降低查找效率。

- 等值联结（内部联结）
```sql
select 表1.列1 ,表2.列2 from 表1 inner join 表2 on 条件;
```
- 外部联结
```sql
select 表1.列1, 表2.列1 from 表1 left outer join 表2 on 条件;
```
`left`表示 `outer join`左边的表对应的列需要全部列出，无论是否满足条件。

虽然联结语句只有左右两个表，但一条语句可并列多个联结语句。
#### 4.2 组合
有时多个 `select`语句可能要求展示的结果是相同的列，此时可用 `union` 将两个 `select`语句结合在连在一起，共同输出

```sql
select ...... union select .....;
```
须注意的是，`union`会自动删除重复的行，如果需要显示，可用 `union all`替代。

#### 4.3 视图
视图不是一个表，但可以看作一个临时的悬浮表使用。如果一次查询的结果对我而言还有可用的价值，可以将其保存在视图中，并赋予一个表名，在之后的查询操作中使用它。
所谓悬浮，主要指视图有表的样子，但并没有表的底层结构。

- `create view`创建视图
```SQL
create view 视图名 as select ...;
```
- `drop`删除视图，同表，数据库的操作类似
- 更新，没有操作，只能删除再建立，或者 `create or replace view`

视图可以更新数据，或删行增行，但尽量别做。

### 5 文本匹配与函数
#### 5.1 文本匹配
假设在商品的表中，希望提取出包含某个字符串的商品名，以及它的价格时，则需要，匹配商品名，如包含‘糖’字的零食。mysql给出了自己的 `like`语句，也支持正则表达式，用 `regexp`语句。

- `like`，后跟 `'匹配模式`
```sql
select 商品名，价格 from 信息表 where 商品名 like '匹配模式';
```
匹配模式，利用 `%`表示任意个数的任意字符，利用 `_`表示一个字符。
需注意的是，这里不支持大小写，也无法匹配对应的大小写。

- `regexp`，用法与 `like` 相同。具体的正则语法可自行查询。
须注意的是，同样不支持大小写匹配，若需要，可在匹配模式前加上 `binary`

#### 5.2 函数
mysql中包含大量函数，支持字符串，数值以及时间的操作，如 **upper()**将字符串转为大写，**length()**给出字符串的长度，**trim()**去掉字符串两端的空格。其它的诸如数值的平均值，总和的函数均可自行查询，日期注意格式须有 `-`连接年月日，`:`连接时分秒，通过**year()**等函数可提出出对应的时间信息。

- 这里重点介绍，字符串中的 `soundex()`函数，该函数将字符串转换为对应的语音表示，如**'lie'** 与 **'lee'**的语音是相同的。该函数可用于文本匹配中，如果不清楚实际的拼写时。

#### 5.3 全文本搜索
全文本搜索首先需要列支持，再创建表时，须声明，
```sql
create 表(
id ...,
文本列,
...,
fulltext(文本列)
)engine=MyISAM;
```
这样每次加入新数据都会对其进行索引，但不要一次加入过多数据。

- 全文本搜索，用 `match() ... against()`语句，
```sql
select 列名 from 表 where match(列名) against('文本');
```
上述语句将提取出包含对应文本的信息，并按照重要度排序，即越靠前，匹配越多，越重要
```sql
select 列名, match(列名) against('文本') as 新列名 from 表;
```
新列名则是对应重要度的数值
1. 扩展查询
在**against()**中后加上 `with query expansion`，将在已有的结果中提取出重要度的关键词，再次查询一遍。
2. 布尔文本搜索
在**against()**中后加上 `in boolean mode`，在前面的文本中使用类似文本匹配的语法
| 布尔操作符 | 功能                 |
| ---------- | -------------------- |
| ""         | 定义短语             |
| -          | 排除                 |
| +          | 必须包含             |
| \*         | 词尾通配符           |
| >          | 包含该词，且等级增加 |
| <          | 包含该词，但等级减小 |
| ()         | 组合表达式           |

### 6 引擎简介
| 特性         | InnoDB | Memory | MyISAM |
| ------------ | ------ | ------ | ------ |
| 存储限制     | 64TB   | RAM    | 256TB  |
| 事务安全     | 支持   | 无     | 无     |
| 空间利用率   | 高     | 低     | 低     |
| 插入数据速度 | 低     | 高     | 高     |
| 外键支持     | 支持   | 否     | 否     |
| 哈希索引     | 否     | 支持   | 否     |
| 集群索引     | 支持   | 否     | 否     |
| 数据索引     | 支持   | 支持   | 否     |
| 数据压缩     | 否     | 否     | 支持   |
| 全文索引     | 无     | 无     | 支持   |


### 7 事务与小编程
#### 7.1 事务
- 所谓事务是指，对数据库的一系列操作，要么全部正确执行，要么一项也别执行，保证数据的正确与安全。

为此，在执行事务时，首先声明开始执行事务，完成一列语句输入后，出现失败，则回滚至之前的状态，或中途设置了保留点，回滚到对应的保留点，若一切无误，则提交所有的命令，完成事务。

```sql
start transaction;--开始事务
.
savepoint 保留点1;
.
--失败
rollback;--或rollback to 保留点1;
.
.
--执行无误
commit;--提交
```
#### 7.2 触发器
触发器是当出现某一活动时，自动执行一系列命令，如插入行前，插入行后，都属于活动。相应的活动只有（insert,delete,update)的前后，也因此，每个表只有6个触发器。
下面主要通过实际编写分析创建与使用，

```sql
create trigger 触发器名 
after insert --也可以是其它活动
on 表名
for each row --对每一行
select '文本';--显示文本
--该命令最终结果是，该表每一次插入行后，都会显示一段文本

create trigger 触发器名
after insert on 表名
for each row
select new.列名;--在insert操作中，存在虚拟表 new,new代表要新的行
--上述的操作代表，每次插入新行后，显示该行对应列的值
--类似的，在delete操作中，可使用 old作为虚拟表代表被删除的行
--在update中，用old与new代替旧行与新行。
drop trigger 触发器名;删除触发器
```
#### 7.3 存储过程
有时，存储一个信息，可能涉及到其它数据的更改，并要求这些更改必须作为一个事务处理，要么全部更新，要么别动，为了简化操作，需要将这些步骤整合在一起，于是，有了这个存储过程，下面，也是通过编写的代码介绍，

```sql
call 存储过程(@参数1,@参数2,...);--调用存储过程，参数可能是返回结果，也可能是作为数据输入
drop procedure 存储过程;--删除
--定义
create procedure 存储过程(
	out 参数1 decimal(8,2),--out代表参数1将获取，decimal()表示数值精度
	in 参数2 int           --in表示参数2的数据将用作计算
)comment '文本'--将显示出文本
delimiter //--临时将分隔符修改为 //，防止';'当作语句的结束符号，导致存储过程失效

begin--正式开始编写过程

declare 局部变量1 属性 default 默认值；--申明一个函数内的变量，指明属性，额外的可以指明默认值

select 函数 from 表 where 参数2 条件 into 局部变量1;--将函数结果输入到局部参数

if 局部变量1 条件 then--符合条件
	select 局部变量1 into 参数1;
end if;

end;--过程编写结束

delimiter ; --将分隔符修改为;
```
#### 7.4 游标
游标是查询结果的一个结果集，使用就像迭代器从中输出数据，且需要在上述的存储过程中使用。下面同样，通过编写代码分析，

```sql
create procedure 存储过程()
begin
declare 游标 cursor--声明了游标
for
select ...;--游标对应的结果集
open 游标;--开启游标

declare 局部变量 属性;
fetch 游标 into 局部变量;--将当前行的数据赋予局部变量

--通过repeat循环检索游标中的数据
decalre done boolean default 0;
declare continue handler for  sqlstate '02000' set done=1;--sqlstate '02000'是一个未找到的条件

repeat
	fetch 游标 into 局部变量;
until done end repeat;

close 游标;--关闭游标

end;

```